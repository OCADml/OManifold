<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cross (OManifold.OManifold.Cross)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">OManifold</a> &#x00BB; <a href="../index.html">OManifold</a> &#x00BB; Cross</nav><header class="odoc-preamble"><h1>Module <code><span>OManifold.Cross</span></code></h1><p>Two-dimensional cross sections guaranteed to be without self-intersections, or overlaps between polygons (from construction onwards)</p></header><nav class="odoc-toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#shapes">Shapes</a></li><li><a href="#booleans">Booleans</a></li><li><a href="#topology">Topology</a></li><li><a href="#transformations">Transformations</a></li><li><a href="#path-simplification-and-offsetting">Path simplification and offsetting</a></li><li><a href="#geometry">Geometry</a></li><li><a href="#conversion">Conversion</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-fill_rule"><a href="#type-fill_rule" class="anchor"></a><code><span><span class="keyword">type</span> fill_rule</span><span> = </span><span>[ </span></code><ol><li id="type-fill_rule.EvenOdd" class="def constructor anchored"><a href="#type-fill_rule.EvenOdd" class="anchor"></a><code><span>| </span></code><code><span>`EvenOdd</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>only odd numbered sub-regions are filled</p><span class="comment-delim">*)</span></div></li><li id="type-fill_rule.NonZero" class="def constructor anchored"><a href="#type-fill_rule.NonZero" class="anchor"></a><code><span>| </span></code><code><span>`NonZero</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>non-zero sub-regions are filled</p><span class="comment-delim">*)</span></div></li><li id="type-fill_rule.Positive" class="def constructor anchored"><a href="#type-fill_rule.Positive" class="anchor"></a><code><span>| </span></code><code><span>`Positive</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>only sub-regions with winding counts <code>&gt; 0</code> are filled</p><span class="comment-delim">*)</span></div></li><li id="type-fill_rule.Negative" class="def constructor anchored"><a href="#type-fill_rule.Negative" class="anchor"></a><code><span>| </span></code><code><span>`Negative</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>only sub-regions with winding counts <code>&lt; 0</code> are filled</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Filling rules used by the clipping algorithm for boolean operations. See Clipper2's docs for a detailed <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper/Types/FillRule.htm">explanation</a> of how they differ).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-join_type"><a href="#type-join_type" class="anchor"></a><code><span><span class="keyword">type</span> join_type</span><span> = </span><span>[ </span></code><ol><li id="type-join_type.Square" class="def constructor anchored"><a href="#type-join_type.Square" class="anchor"></a><code><span>| </span></code><code><span>`Square</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>squaring applied uniformally at all joins where the <i>internal</i> join angle is less than 90 degrees. The squared edg will be at exactly the offset distance from the join vertex</p><span class="comment-delim">*)</span></div></li><li id="type-join_type.Round" class="def constructor anchored"><a href="#type-join_type.Round" class="anchor"></a><code><span>| </span></code><code><span>`Round</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>rounding is appliedto all joins that have convex external angles, and it maintains the exact offset distance from the join vertex</p><span class="comment-delim">*)</span></div></li><li id="type-join_type.Miter" class="def constructor anchored"><a href="#type-join_type.Miter" class="anchor"></a><code><span>| </span></code><code><span>`Miter</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>there's a necessary limit to mitered joins (to avoid narrow angled joins producing excessively long and narrow <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper.Offset/Classes/ClipperOffset/Properties/MiterLimit.htm">spikes</a>)). The limit sets the maximum distance in multiples of the <code>delta</code> specified for the offsetting operation (default is <code>2.</code>, which is the minimum allowed).</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Defines the treatment of corners when offsetting paths. Visual examples are available in the Clipper2 <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper/Types/JoinType.htm">docs</a>.</p></div></div><h2 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h2><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>empty ()</code></p><p>Create an empty cross-section containing no contours.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_path"><a href="#val-of_path" class="anchor"></a><code><span><span class="keyword">val</span> of_path : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.Path2.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_path ?fill_rule path</code></p><p>Create a 2d cross-section from a single outline <code>path</code>. A boolean union operation (with <code>`Positive</code> filling rule by default) is performed to ensure the resulting cross-section is free of self-intersections.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_paths"><a href="#val-of_paths" class="anchor"></a><code><span><span class="keyword">val</span> of_paths : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">OCADml</span>.Path2.t list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_paths ?fill_rule paths</code></p><p>Create a 2d cross-section from a set of closed <code>paths</code> (zero or more complex polygons). A boolean union operation (with <code>`Positive</code> filling rule by default) is performed to combine overlapping polygons and ensure the resulting cross-section is free of intersections.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_poly2"><a href="#val-of_poly2" class="anchor"></a><code><span><span class="keyword">val</span> of_poly2 : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.Poly2.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_poly2 ?fill_rule poly</code></p><p>Create a 2d cross-section from an OCADml polygon. A boolean union operation (with <code>`Positive</code> filling rule by default) is performed to combine overlapping polygons and ensure the resulting cross-section is free of intersections.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_poly2s"><a href="#val-of_poly2s" class="anchor"></a><code><span><span class="keyword">val</span> of_poly2s : <span>?fill_rule:<a href="#type-fill_rule">fill_rule</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">OCADml</span>.Poly2.t list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_poly2 ?fill_rule poly</code></p><p>Create a 2d cross-section from a list of OCADml polygons. A boolean union operation (with <code>`Positive</code> filling rule by default) is performed to combine overlapping polygons and ensure the resulting cross-section is free of intersections.</p></div></div><h2 id="shapes"><a href="#shapes" class="anchor"></a>Shapes</h2><div class="odoc-spec"><div class="spec value anchored" id="val-circle"><a href="#val-circle" class="anchor"></a><code><span><span class="keyword">val</span> circle : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>circle ?fn r</code></p><p>Create a circular cross-section with radius <code>r</code>. <code>fn</code> can be provided to set the number of segments that it should be drawn with, otherwise it will be determined according to the globals governed by <a href="../Quality/index.html"><code>OManifold.Quality</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-square"><a href="#val-square" class="anchor"></a><code><span><span class="keyword">val</span> square : <span>?center:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>square ?center dims</code></p><p>Create a square with the given XY <code>dims</code>. By default it is positioned in the first quadrant, touching the origin. Setting <code>~center:true</code> will instead centre the shape on the origin. If any dimensions in size are negative, or if all are zero, an empty <a href="../Manifold/index.html#type-t"><code>Manifold.t</code></a> will be returned.</p></div></div><h2 id="booleans"><a href="#booleans" class="anchor"></a>Booleans</h2><div class="odoc-spec"><div class="spec value anchored" id="val-boolean"><a href="#val-boolean" class="anchor"></a><code><span><span class="keyword">val</span> boolean : <span>op:<span>[ `Add <span>| `Subtract</span> <span>| `Intersect</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>boolean ~op a b</code></p><p>Compute the boolean operation <code>op</code> between the cross-sections <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-batch_boolean"><a href="#val-batch_boolean" class="anchor"></a><code><span><span class="keyword">val</span> batch_boolean : <span>op:<span>[ `Add <span>| `Subtract</span> <span>| `Intersect</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>batch_boolean ~op cs</code></p><p>Compute the boolean operation <code>op</code> on the list of cross-sections <code>cs</code>. In the case of <code>~op:`Subtract</code>, the tail is differenced from the head.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add a b</code></p><p>Union (logical <b>or</b>) the cross-sections <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>union ts</code></p><p>Union (logical <b>or</b>) the list of cross-sections <code>ts</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub a b</code></p><p>Subtract (logical <b>and not</b>) the cross-section <code>b</code> from the cross-section <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-difference"><a href="#val-difference" class="anchor"></a><code><span><span class="keyword">val</span> difference : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>difference t d</code></p><p>Subtract (logical <b>and not</b>) the list of cross-sections <code>d</code> from the cross-section <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span><span class="keyword">val</span> intersect : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>intersect a b</code></p><p>Compute the intersection (logical <b>and</b>) of the cross-sections <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersection"><a href="#val-intersection" class="anchor"></a><code><span><span class="keyword">val</span> intersection : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>intersection ts</code></p><p>Compute the intersection (logical <b>and</b>) of the cross-sections <code>ts</code>. Only the area which is common or shared by <b>all</b> shapes are retained. If <code>ts</code> is empty, an empty cross-section <a href="#type-t"><code>t</code></a> will result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rect_clip"><a href="#val-rect_clip" class="anchor"></a><code><span><span class="keyword">val</span> rect_clip : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.Box2.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rect_clip t rect</code></p><p>Compute the intersection between the cross-section <code>t</code> and an axis-aligned bounding box <code>rect</code>. This operation has much higher performance (<b>O(n)</b> vs <b>O(n<sup>3</sup>)</b> than the general purpose intersection algorithm used for sets of cross-sections.</p></div></div><h2 id="topology"><a href="#topology" class="anchor"></a>Topology</h2><div class="odoc-spec"><div class="spec value anchored" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span><span class="keyword">val</span> compose : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>compose ts</code></p><p>Create a cross-section from a list of cross-sections <code>ts</code> (see <a href="#val-union"><code>union</code></a>). Unlike <a href="../Manifold/index.html#val-compose"><code>Manifold.compose</code></a>, it isn't necessary that the input shapes are non-overlapping as a clipping operation is performed here.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decompose"><a href="#val-decompose" class="anchor"></a><code><span><span class="keyword">val</span> decompose : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>decompose t</code></p><p>Break the cross-section <code>t</code> into a list of topologically disconnected cross-sections, each containing one outline contour with zero or more holes.</p></div></div><h2 id="transformations"><a href="#transformations" class="anchor"></a>Transformations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>translate p t</code></p><p>Move <code>t</code> along the vector <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xtrans"><a href="#val-xtrans" class="anchor"></a><code><span><span class="keyword">val</span> xtrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>xtrans x t</code></p><p>Move <code>t</code> by the distance <code>x</code> along the x-axis.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ytrans"><a href="#val-ytrans" class="anchor"></a><code><span><span class="keyword">val</span> ytrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ytrans y t</code></p><p>Move <code>t</code> by the distance <code>y</code> along the y-axis.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate"><a href="#val-rotate" class="anchor"></a><code><span><span class="keyword">val</span> rotate : <span>?about:<span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rotate ?about r t</code></p><p>Rotate the cross-section <code>t</code> around the z-axis through the origin (or the point <code>about</code> if provided) by <code>r</code> (in radians).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zrot"><a href="#val-zrot" class="anchor"></a><code><span><span class="keyword">val</span> zrot : <span>?about:<span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>zrot ?about r t</code></p><p>Rotate the cross-section <code>t</code> around the z-axis through the origin (or the point <code>about</code> if provided) by <code>r</code> (in radians).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mirror"><a href="#val-mirror" class="anchor"></a><code><span><span class="keyword">val</span> mirror : <span><span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mirror ax t</code></p><p>Mirror the cross-seciton <code>t</code> over the arbitrary axis described by the unit form of the vector <code>ax</code>. If the length of <code>ax</code> is zero, an empty cross-section is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-affine"><a href="#val-affine" class="anchor"></a><code><span><span class="keyword">val</span> affine : <span><span class="xref-unresolved">OCADml</span>.Affine2.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>affine m t</code></p><p>Transform the cross-section <code>t</code> with the affine transformation matrix <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scale"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>scale factors t</code></p><p>Scales <code>t</code> by the given <code>factors</code> in xy.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xscale"><a href="#val-xscale" class="anchor"></a><code><span><span class="keyword">val</span> xscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>xscale s t</code></p><p>Scales <code>t</code> by the factor <code>s</code> in the x-dimension.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yscale"><a href="#val-yscale" class="anchor"></a><code><span><span class="keyword">val</span> yscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>yscale s t</code></p><p>Scales <code>t</code> by the factor <code>s</code> in the y-dimension.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-warp"><a href="#val-warp" class="anchor"></a><code><span><span class="keyword">val</span> warp : <span><span>(<span><span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">OCADml</span>.v2)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>warp f t</code></p><p>Map over the vertices of the cross-section <code>t</code> with the function <code>f</code>, followed by a union operation ensuring that the result is free of intersections.</p></div></div><h2 id="path-simplification-and-offsetting"><a href="#path-simplification-and-offsetting" class="anchor"></a>Path simplification and offsetting</h2><div class="odoc-spec"><div class="spec value anchored" id="val-simplify"><a href="#val-simplify" class="anchor"></a><code><span><span class="keyword">val</span> simplify : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>simplify ?eps t</code></p><p>Remove vertices from the contours in <code>t</code> that are less than the specified distance <code>eps</code> from an imaginary line that passes through its two adjacent vertices. Near duplicate vertices and collinear points will be removed at lower <code>eps</code>ilons, with elimination of line segments becoming increasingly aggressive with larger <code>eps</code>ilons.</p><p>It is recommended to apply this function following <a href="#val-offset"><code>offset</code></a>, in order to clean up any spurious tiny line segments introduced that do not improve quality in any meaningful way. This is particularly important if further offseting operations are to be performed, which would compound the issue.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-offset"><a href="#val-offset" class="anchor"></a><code><span><span class="keyword">val</span> offset : 
  <span>?join_type:<a href="#type-join_type">join_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?miter_limit:float <span class="arrow">&#45;&gt;</span></span>
  <span>?arc_tolerance:float <span class="arrow">&#45;&gt;</span></span>
  <span>delta:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>offset ?join_type ?miter_limit ?arc_tolerance ~delta t</code></p><p>Inflate the contours in the cross-section <code>t</code> by the <code>delta</code>, handling corners according to <code>join_type</code> (default = <code>`Square</code>). Positive <code>delta</code> will cause the expansion of outlining contours to expand, and retraction of inner (hole) contours. Negative deltas will have the opposite effect.</p><ul><li><code>miter_limit</code> sets maximum distance in multiples of delta that vertices can be offset from their original positions with before squaring is applied, <b>when the join type is <code>`Miter</code></b> (default is <code>2.</code>, which is the minimum allowed). See the <a href="http://www.angusj.com/clipper2/Docs/Units/Clipper.Offset/Classes/ClipperOffset/Properties/MiterLimit.htm">Clipper2 MiterLimit</a> page for a visual example.</li><li><code>arc_tolerance</code> sets the maximum acceptable imperfection for curves drawn (approximated with line segments) for <code>`Round</code> joins (not relevant for other <code>join_type</code>s). By default the allowable imprecision is scaled in inverse proportion to the offset delta.</li></ul></div></div><h2 id="geometry"><a href="#geometry" class="anchor"></a>Geometry</h2><div class="odoc-spec"><div class="spec value anchored" id="val-bounds"><a href="#val-bounds" class="anchor"></a><code><span><span class="keyword">val</span> bounds : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">OCADml</span>.Box2.t</span></code></div><div class="spec-doc"><p><code>bounds t</code></p><p>Compute the axis-aligned bounding rectangle of all of the cross-section <code>t</code>'s vertices.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-area"><a href="#val-area" class="anchor"></a><code><span><span class="keyword">val</span> area : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>area t</code></p><p>Compute the total area covered by complex polygons making up the cross-section <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-num_vert"><a href="#val-num_vert" class="anchor"></a><code><span><span class="keyword">val</span> num_vert : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_vert t</code></p><p>The number of vertices in the cross-section <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-num_contour"><a href="#val-num_contour" class="anchor"></a><code><span><span class="keyword">val</span> num_contour : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_contour t</code></p><p>The number of contours in the cross-section <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty t</code></p><p>Does the cross-section <code>t</code> contain zero contours?</p></div></div><h2 id="conversion"><a href="#conversion" class="anchor"></a>Conversion</h2><div class="odoc-spec"><div class="spec value anchored" id="val-to_paths"><a href="#val-to_paths" class="anchor"></a><code><span><span class="keyword">val</span> to_paths : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.Path2.t list</span></span></code></div><div class="spec-doc"><p><code>to_paths t</code></p><p>Extract the contours (closed paths) from <code>t</code>, describing zero or more complex polygons. If a list describing a single complex polygon with the its outline at the head, and inner/hole paths in the tail, one should first apply <a href="#val-decompose"><code>decompose</code></a>.</p></div></div></div></body></html>
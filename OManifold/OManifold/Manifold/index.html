<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Manifold (OManifold.OManifold.Manifold)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">OManifold</a> &#x00BB; <a href="../index.html">OManifold</a> &#x00BB; Manifold</nav><header class="odoc-preamble"><h1>Module <code><span>OManifold.Manifold</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#basic-constructors">Basic Constructors</a></li><li><a href="#topology">Topology</a></li><li><a href="#shapes">Shapes</a></li><li><a href="#mesh-conversions">Mesh Conversions</a></li><li><a href="#2d-to-3d">2D to 3D</a></li><li><a href="#booleans">Booleans</a></li><li><a href="#transformations">Transformations</a></li><li><a href="#data-extraction">Data Extraction</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Id"><a href="#module-Id" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Id/index.html">Id</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-size"><a href="#type-size" class="anchor"></a><code><span><span class="keyword">type</span> size</span><span> = </span><span>{</span></code><ol><li id="type-size.surface_area" class="def record field anchored"><a href="#type-size.surface_area" class="anchor"></a><code><span>surface_area : float;</span></code></li><li id="type-size.volume" class="def record field anchored"><a href="#type-size.volume" class="anchor"></a><code><span>volume : float;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Spatial properties of a <a href="#type-t"><code>Manifold.t</code></a>, returned by <a href="#val-size"><code>size</code></a></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><h2 id="basic-constructors"><a href="#basic-constructors" class="anchor"></a>Basic Constructors</h2><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>empty ()</code></p><p>Construct an empty manifold.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>copy t</code></p><p>Return a copy of the manifold <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-as_original"><a href="#val-as_original" class="anchor"></a><code><span><span class="keyword">val</span> as_original : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>as_original t</code></p><p>If you copy a manifold, but you want this new copy to have new properties (e.g. a different UV mapping), you can reset its relational ids (as found in <code>MeshGl</code>.t to new originals, meaning it will now be referenced by its descendents instead of the meshes it was built from, allowing you to differentiate the copies when applying your properties to the final result.</p><p>This function also condenses all coplanar faces in the relation, and collapses those edges. If you want to have inconsistent properties across these faces, meaning you want to preserve some of these edges, you should instead use <code>to_meshgl</code>, calculate your properties and use these to construct a new manifold.</p></div></div><h2 id="topology"><a href="#topology" class="anchor"></a>Topology</h2><div class="odoc-spec"><div class="spec value anchored" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span><span class="keyword">val</span> compose : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>compose ts</code> Constructs a new manifold from a list of other manifolds. This is a purely topological operation, so care should be taken to avoid creating overlapping results. It is the inverse operation of <a href="#val-decompose"><code>decompose</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decompose"><a href="#val-decompose" class="anchor"></a><code><span><span class="keyword">val</span> decompose : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>decompose t</code></p><p>This operation returns a list of manifolds that are topologically disconnected. If everything is connected, the result is singular copy of the original. It is the inverse operation of <a href="#val-compose"><code>compose</code></a>.</p></div></div><h2 id="shapes"><a href="#shapes" class="anchor"></a>Shapes</h2><div class="odoc-spec"><div class="spec value anchored" id="val-tetrahedron"><a href="#val-tetrahedron" class="anchor"></a><code><span><span class="keyword">val</span> tetrahedron : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>tetrahedron ()</code></p><p>Create a tetrahedron centred at the origin with one vertex at <code>(v3 1. 1. 1.)</code> and the rest at similarly symmetric points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sphere"><a href="#val-sphere" class="anchor"></a><code><span><span class="keyword">val</span> sphere : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sphere ?fn radius</code></p><p>Create a sphere with given <code>radius</code> at the origin of the coordinate system. The number of segments along the diameter can be explicitly set by <code>fn</code>, otherwise it is determined by the <span class="xref-unresolved">quality globals</span>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cube"><a href="#val-cube" class="anchor"></a><code><span><span class="keyword">val</span> cube : <span>?center:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>cube ?center dimensions</code></p><p>Create a cube in the first octant, with the given xyz <code>dimensions</code>. When <code>center</code> is true, the cube is centered on the origin.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cylinder"><a href="#val-cylinder" class="anchor"></a><code><span><span class="keyword">val</span> cylinder : <span>?center:bool <span class="arrow">&#45;&gt;</span></span> <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>height:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>cylinder ?center ?fn ~height radius</code></p><p>Creates a cylinder centered about the z-axis. When <code>center</code> is true, it will also be centered vertically, otherwise the base will sit upon the XY plane. The number of segments along the diameter can be explicitly set by <code>fn</code>, otherwise it is determined by the <span class="xref-unresolved">quality globals</span>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cone"><a href="#val-cone" class="anchor"></a><code><span><span class="keyword">val</span> cone : <span>?center:bool <span class="arrow">&#45;&gt;</span></span> <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>height:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>cone ?center ?fn ~height r1 r2 </code></p><p>Create cone with bottom radius <code>r1</code> and top radius <code>r2</code>. When <code>center</code> is true, it will also be centered vertically, otherwise the base will sit upon the XY plane. The number of segments along the diameter can be explicitly set by <code>fn</code>, otherwise it is determined by the <span class="xref-unresolved">quality globals</span>.</p></div></div><h2 id="mesh-conversions"><a href="#mesh-conversions" class="anchor"></a>Mesh Conversions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-of_mmeshgl"><a href="#val-of_mmeshgl" class="anchor"></a><code><span><span class="keyword">val</span> of_mmeshgl : <span><a href="../MMeshGL/index.html#type-t">MMeshGL.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>of_mmeshgl m</code></p><p>Create a manifold from the mesh <code>m</code>, returning <code>Error</code> if <code>m</code> is not an oriented 2-manifold. Will collapse degenerate triangles and unnecessary vertices.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_mmeshgl_exn"><a href="#val-of_mmeshgl_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_mmeshgl_exn : <span><a href="../MMeshGL/index.html#type-t">MMeshGL.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_mmeshgl_exn ?properties m</code></p><p>Same as <code>of_mmesh</code>, but raising a <code>Failure</code> rather than returning an <code>Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_mesh"><a href="#val-of_mesh" class="anchor"></a><code><span><span class="keyword">val</span> of_mesh : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.Mesh.t <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>of_mesh ?rev m</code></p><p>Create a manifold from an OCADml mesh <code>m</code>, returning <code>Error</code> if <code>m</code> is not an oriented 2-manifold. Will collapse degenerate triangles and unnecessary vertices. If <code>rev</code> is <code>true</code> (as it is by default), faces of the input mesh are reversed (as the winding convention in OCADml is opposite to Manifold)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_mesh_exn"><a href="#val-of_mesh_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_mesh_exn : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.Mesh.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_mesh_exn ?rev m</code></p><p>Same as <a href="#val-of_mesh"><code>of_mesh</code></a>, but raising a <code>Failure</code> rather than returning an <code>Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-smooth"><a href="#val-smooth" class="anchor"></a><code><span><span class="keyword">val</span> smooth : 
  <span>?smoothness:<span><span>(int * float)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../MMeshGL/index.html#type-t">MMeshGL.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>smooth ?smoothness m</code></p><p>Constructs a smooth version of the input mesh <code>m</code> by creating tangents, returning an error if you have already supplied tangents for it. The actual triangle resolution is unchanged, thus you will likely want to follow up with <a href="#val-refine"><code>refine</code></a> to interpolate to higher-resolution curves.</p><p>By default, every edge is calculated for maximum smoothness (very much approximately), attempting to minimize the maximum mean Curvature magnitude. No higher-order derivatives are considered, as the interpolation is independent per triangle, only sharing constraints on their boundaries. To control the relative smoothness at particular halfedges (ideally limited to a small subset of all halfedges), <code>smoothness</code> can be provided with <code>(index, s)</code> pairs specifying a smoothness factor <code>s</code> between <code>0.</code> and <code>1.</code> for the <code>index</code> interperpreted as <code>3 * triangle + {0,1,2}</code> where <code>0</code> is the edge between the first and second vertices of the <code>triangle</code>.</p><p>At a smoothness value of zero, a sharp crease is made. The smoothness is interpolated along each edge, so the specified value should be thought of as an average. Where exactly two sharpened edges meet at a vertex, their tangents are rotated to be colinear so that the sharpened edge can be continuous. Vertices with only one sharpened edge are completely smooth, allowing sharpened edges to smoothly vanish at termination. A single vertex can be sharpened by sharping all edges that are incident on it, allowing cones to be formed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-smooth_exn"><a href="#val-smooth_exn" class="anchor"></a><code><span><span class="keyword">val</span> smooth_exn : <span>?smoothness:<span><span>(int * float)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../MMeshGL/index.html#type-t">MMeshGL.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>smooth_exn ?smoothness m</code></p><p>Same as <a href="#val-smooth"><code>smooth</code></a>, but raising <code>Failure</code> rather than returning <code>Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_mmeshgl"><a href="#val-to_mmeshgl" class="anchor"></a><code><span><span class="keyword">val</span> to_mmeshgl : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../MMeshGL/index.html#type-t">MMeshGL.t</a></span></code></div><div class="spec-doc"><p><code>to_mmeshgl t</code></p><p>Obtain a graphics library (gl) friendly mesh representation of the manifold <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_mesh"><a href="#val-to_mesh" class="anchor"></a><code><span><span class="keyword">val</span> to_mesh : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">OCADml</span>.Mesh.t</span></code></div><div class="spec-doc"><p><code>to_mesh t</code></p><p>Obtain an OCADml mesh describing the shape ot the manifold <code>t</code>.</p></div></div><h2 id="2d-to-3d"><a href="#2d-to-3d" class="anchor"></a>2D to 3D</h2><div class="odoc-spec"><div class="spec value anchored" id="val-extrude"><a href="#val-extrude" class="anchor"></a><code><span><span class="keyword">val</span> extrude : 
  <span>?slices:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<span class="xref-unresolved">OCADml</span>.v2 <span class="arrow">&#45;&gt;</span></span>
  <span>?center:bool <span class="arrow">&#45;&gt;</span></span>
  <span>height:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../CrossSection/index.html#type-t">CrossSection.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extrude ?slices ?twist ?scale ~height cross_section</code></p><p>Vertically extrude a 2d <code>cross_section</code> from the XY plane to <code>height</code>. If <code>?center</code> is <code>true</code>, the resulting 3D object is centered around the XY plane, rather than resting on top of it.</p><ul><li><code>?twist</code> rotates the shape by the specified angle (in radians) as it is extruded upwards</li><li><code>?slices</code> specifies the number of intermediate points along the Z axis of the extrusion. By default this increases with the value of <code>?twist</code>, though manual refinement may improve results.</li><li><code>?scale</code> expands or contracts the shape in X and Y as it is extruded upward. Default is <code>(v2 1. 1.)</code>, no scaling. If set to <code>(v2 0. 0.)</code>, a pure cone is formed, with only a single vertex at the top.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-revolve"><a href="#val-revolve" class="anchor"></a><code><span><span class="keyword">val</span> revolve : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../CrossSection/index.html#type-t">CrossSection.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>revolve ?fn cross_section</code></p><p>Revolve a 2d <code>cross_section</code> around the y-axis and then set this as the z-axis of the resulting manifold. If the polygons cross the y-axis, only the part on the positive x side is used. Geometrically valid input will result in geometrically valid output. The number of segments in the revolution can be set explicitly with <code>fn</code>, otherwise it is determined by the <span class="xref-unresolved">quality globals</span>.</p></div></div><h2 id="booleans"><a href="#booleans" class="anchor"></a>Booleans</h2><div class="odoc-spec"><div class="spec value anchored" id="val-boolean"><a href="#val-boolean" class="anchor"></a><code><span><span class="keyword">val</span> boolean : <span>op:<a href="../index.html#type-op_type">op_type</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-batch_boolean"><a href="#val-batch_boolean" class="anchor"></a><code><span><span class="keyword">val</span> batch_boolean : <span>op:<a href="../index.html#type-op_type">op_type</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add a b</code></p><p>Union (logical <b>or</b>) the manifolds <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>union ts</code></p><p>Union (logical <b>or</b>) the list of manifolds <code>ts</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub a b</code></p><p>Subtract (logical <b>and not</b>) the manifold <code>b</code> from the manifold <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-difference"><a href="#val-difference" class="anchor"></a><code><span><span class="keyword">val</span> difference : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>difference t d</code></p><p>Subtract (logical <b>and not</b>) the list of manifolds <code>d</code> from the manifold <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersection"><a href="#val-intersection" class="anchor"></a><code><span><span class="keyword">val</span> intersection : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>intersection ts</code></p><p>Compute the intersection (logical <b>and</b>) of the manifolds <code>ts</code>. Only the area which is common or shared by <b>all</b> shapes are retained. If <code>ts</code> is empty, an empty manifold <a href="#type-t"><code>t</code></a> will result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split a b</code></p><p>Splits the manifold <code>a</code> into two using the cutter manifold <code>b</code>. The first result is the intersection, and the second is the difference.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_by_plane"><a href="#val-split_by_plane" class="anchor"></a><code><span><span class="keyword">val</span> split_by_plane : <span><span class="xref-unresolved">OCADml</span>.Plane.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split_by_plane p t</code></p><p>Splits the manifold <code>t</code> in two, one above the plane <code>p</code>, and the other below.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trim_by_plane"><a href="#val-trim_by_plane" class="anchor"></a><code><span><span class="keyword">val</span> trim_by_plane : <span><span class="xref-unresolved">OCADml</span>.Plane.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>trim_by_plane p t</code></p><p>Cut away the portion of the manifold <code>t</code> lying below the plane <code>p</code>.</p></div></div><h2 id="transformations"><a href="#transformations" class="anchor"></a>Transformations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>translate p t</code></p><p>Move <code>t</code> along the vector <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xtrans"><a href="#val-xtrans" class="anchor"></a><code><span><span class="keyword">val</span> xtrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>xtrans x t</code></p><p>Move <code>t</code> by the distance <code>x</code> along the x-axis.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ytrans"><a href="#val-ytrans" class="anchor"></a><code><span><span class="keyword">val</span> ytrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ytrans y t</code></p><p>Move <code>t</code> by the distance <code>y</code> along the y-axis.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ztrans"><a href="#val-ztrans" class="anchor"></a><code><span><span class="keyword">val</span> ztrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ztrans z t</code></p><p>Move <code>t</code> by the distance <code>z</code> along the z-axis.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate"><a href="#val-rotate" class="anchor"></a><code><span><span class="keyword">val</span> rotate : <span>?about:<span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rotate ?about r t</code></p><p>Performs an Euler rotation (zyx). If it is provided, rotations are performed around the point <code>about</code>, otherwise rotation is about the origin. Angle(s) <code>r</code> are in radians.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xrot"><a href="#val-xrot" class="anchor"></a><code><span><span class="keyword">val</span> xrot : <span>?about:<span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>xrot ?about r t</code></p><p>Rotate the manifold <code>t</code> around the x-axis through the origin (or the point <code>about</code> if provided) by <code>r</code> (in radians).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yrot"><a href="#val-yrot" class="anchor"></a><code><span><span class="keyword">val</span> yrot : <span>?about:<span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>yrot ?about r t</code></p><p>Rotate the manifold <code>t</code> around the y-axis through the origin (or the point <code>about</code> if provided) by <code>r</code> (in radians).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zrot"><a href="#val-zrot" class="anchor"></a><code><span><span class="keyword">val</span> zrot : <span>?about:<span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>zrot ?about r t</code></p><p>Rotate the manifold <code>t</code> around the z-axis through the origin (or the point <code>about</code> if provided) by <code>r</code> (in radians).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-affine"><a href="#val-affine" class="anchor"></a><code><span><span class="keyword">val</span> affine : <span><span class="xref-unresolved">OCADml</span>.Affine3.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>affine m t</code></p><p>Transform the manifold <code>t</code> with the affine transformation matrix <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quaternion"><a href="#val-quaternion" class="anchor"></a><code><span><span class="keyword">val</span> quaternion : <span>?about:<span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.Quaternion.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>quaternion ?about q t</code></p><p>Applys the quaternion rotation <code>q</code> around the origin (or the point <code>about</code> if provided) to <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_rotate"><a href="#val-axis_rotate" class="anchor"></a><code><span><span class="keyword">val</span> axis_rotate : <span>?about:<span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>axis_rotate ?about ax r t</code></p><p>Rotates <code>t</code> about the arbitrary axis <code>ax</code> through the origin (or the point <code>about</code> if provided) by the angle <code>r</code> (in radians).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-warp"><a href="#val-warp" class="anchor"></a><code><span><span class="keyword">val</span> warp : <span><span>(<span><span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">OCADml</span>.v3)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>warp f t</code></p><p>Map over the vertices of the manifold <code>t</code> with the function <code>f</code>, allowing their positions to be updated arbitrarily, but note that the topology is unchanged. It is easy to create a function that warps a geometrically valid object into one which overlaps, but that is not checked here, so it is up to the user to choose their function with discretion.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scale"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><span class="xref-unresolved">OCADml</span>.v3 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>scale factors t</code></p><p>Scales <code>t</code> by the given <code>factors</code> in xyz.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xscale"><a href="#val-xscale" class="anchor"></a><code><span><span class="keyword">val</span> xscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>xscale s t</code></p><p>Scales <code>t</code> by the factor <code>s</code> in the x-dimension.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yscale"><a href="#val-yscale" class="anchor"></a><code><span><span class="keyword">val</span> yscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>yscale s t</code></p><p>Scales <code>t</code> by the factor <code>s</code> in the y-dimension.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zscale"><a href="#val-zscale" class="anchor"></a><code><span><span class="keyword">val</span> zscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>zscale s t</code></p><p>Scales <code>t</code> by the factor <code>s</code> in the z-dimension.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-refine"><a href="#val-refine" class="anchor"></a><code><span><span class="keyword">val</span> refine : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>refine n t</code></p><p>Increase the density of the meshes in <code>t</code> by splitting every edge into <code>n</code> pieces. For instance, with <code>n = 2</code>, each triangle will be split into 4 triangles. These will all be coplanar (and will not be immediately collapsed) unless the contained <a href="../MMeshGL/index.html#type-t"><code>MMeshGL.t</code></a> within has <a href="../MMeshGL/index.html#val-halfedge_tangents"><code>MMeshGL.halfedge_tangents</code></a> specified (e.g. from the <a href="#val-smooth"><code>smooth</code></a> constructor), in which case the new vertices will be moved to the interpolated surface according to their barycentric coordinates.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hull"><a href="#val-hull" class="anchor"></a><code><span><span class="keyword">val</span> hull : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>hull ts</code></p><p>Create a convex hull that encloses all of the vertices of the manifolds in <code>ts</code>. Note that this operation comes from OCADml and is not guaranteed to produce a valid manifold.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hull_exn"><a href="#val-hull_exn" class="anchor"></a><code><span><span class="keyword">val</span> hull_exn : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>hull_exn ts</code></p><p>Same as <a href="#val-hull"><code>hull</code></a>, but a <code>Failure</code> is raised if the resulting mesh does not describe a valid manifold.</p></div></div><h2 id="data-extraction"><a href="#data-extraction" class="anchor"></a>Data Extraction</h2><div class="odoc-spec"><div class="spec value anchored" id="val-original_id"><a href="#val-original_id" class="anchor"></a><code><span><span class="keyword">val</span> original_id : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Id/index.html#type-t">Id.t</a></span></code></div><div class="spec-doc"><p><code>original_id t</code></p><p>If this mesh is an original, this returns it unique id that can be referenced by product manifolds (for the purposes of reappling mesh properties).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-num_vert"><a href="#val-num_vert" class="anchor"></a><code><span><span class="keyword">val</span> num_vert : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_vert t</code></p><p>The number of vertices in the manifold <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-num_edge"><a href="#val-num_edge" class="anchor"></a><code><span><span class="keyword">val</span> num_edge : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_edge t</code></p><p>The number of edges in the manifold <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-num_tri"><a href="#val-num_tri" class="anchor"></a><code><span><span class="keyword">val</span> num_tri : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_tri t</code></p><p>The number of triangles in the manifold <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bounding_box"><a href="#val-bounding_box" class="anchor"></a><code><span><span class="keyword">val</span> bounding_box : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../MBox/index.html#type-t">MBox.t</a></span></code></div><div class="spec-doc"><p><code>bounding_box t</code></p><p>Return the axis-aligned bounding box of all of the manifold <code>t</code>'s vertices.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-precision"><a href="#val-precision" class="anchor"></a><code><span><span class="keyword">val</span> precision : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>precision t</code></p><p>Returns the precision of this manifold's vertices, which tracks the approximate rounding error over all the transforms and operations that have led to this state. Any triangles that are colinear within this precision are considered degenerate and removed. This is the value of &amp;epsilon; defining <a href="https://github.com/elalish/manifold/wiki/manifold-Library#definition-of-%CE%B5-valid">&amp;epsilon;-valid</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genus"><a href="#val-genus" class="anchor"></a><code><span><span class="keyword">val</span> genus : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>genus t</code></p><p>The genus is a topological property of the manifold, representing the number of &quot;handles&quot;. A sphere is 0, torus 1, etc. It is only meaningful for a single mesh, so it is best use <a href="#val-decompose"><code>decompose</code></a> first.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size"><a href="#val-size" class="anchor"></a><code><span><span class="keyword">val</span> size : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-size">size</a></span></code></div><div class="spec-doc"><p><code>size t</code></p><p>The physical size (surface area and volume) of the manifold <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-curvature"><a href="#val-curvature" class="anchor"></a><code><span><span class="keyword">val</span> curvature : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Curvature/index.html#type-t">Curvature.t</a></span></code></div><div class="spec-doc"><p><code>curvature t</code></p><p>The inverse of the radius of curvature, and signed such that positive is convex and negative is concave. There are two orthogonal principal curvatures at any point on a manifold, with one maximum and the other minimum. Gaussian curvature is their product, while mean curvature is their sum. This approximates them for every vertex (returned as vectors in the structure) and also returns their minimum and maximum values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-points"><a href="#val-points" class="anchor"></a><code><span><span class="keyword">val</span> points : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">OCADml</span>.v3 list</span></span></code></div><div class="spec-doc"><p><code>points t</code></p><p>Retrieve the points making up the meshes of the manifold <code>t</code>.</p></div></div></div></body></html>